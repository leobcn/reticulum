{"name":"Reticulum","google":"","tagline":"Distributed Image Server","body":"Reticulum\r\n=========\r\n\r\nReticulum is a distributed image and thumbnail server.\r\n\r\nHistory/Motivation\r\n------------------\r\n\r\nWhen building web applications that allow users to upload images, one\r\nfaces a number of challenges. \r\n\r\nA naive approach is to allow the users to upload the image file, dump\r\nit into a directory on the same server as the web-server, and the\r\nprovide a way to access the uploaded image via a URL. Almost\r\nimmediately, you will realize that users can and will upload images of\r\nany size and you can't just serve the full-size images. You will\r\nalmost certainly want to scale the images down to reasonable web\r\nsize. Probably even more than one size, as it's common to have a\r\nmedium sized view of the image as well as small thumbnails for index\r\npages. A typical response to this is to, when accepting the upload,\r\nuse Imagemagick, PIL or something similar to create a couple scaled\r\nversions of the images and save those alongside the original\r\nimage. This may be good enough for many applications. In my experience\r\nthough, I run into trouble when the design of the site changes and\r\nthen different size thumbnails are needed than what were originally\r\ncreated. For design flexibility, I've been impressed with the approach\r\nof sorl.thumbnail, a popular Django image thumbnailing library. Sorl\r\nprovides a template tag (and model field type) where the designer can\r\nspecify the dimensions of the thumbnail to generate in the HTML\r\ntemplates and sorl creates that thumbnail as the page loads (if\r\nnecessary). The downside to that approach is that it requires the\r\ndirectory of images to be at least mounted by the web application\r\nserver (if not just on the same disk). For even moderately large or\r\nhigh traffic sites, it is problematic to couple the image/file server\r\nand application server so tightly. It also requires PIL, a fairly\r\nheavyweight Python library to be compiled and installed on the app\r\nserver and loaded into memory.\r\n\r\nImage upload directories with a fair number of images and derived\r\nthumbnails also tend to have large numbers of files and directories\r\nand can become fairly tricky to efficiently backup and/or replicate\r\nfor higher availability. \r\n\r\nFor addressing replication and high availability, I've experimented\r\nwith Tahoe-LAFS, a web-based distributed filesystem. I like Tahoe-LAFS\r\nfor many applications, but it does not deal well with this image\r\nserving use-case since files stored in Tahoe-LAFS are not directly\r\navailable as files on a filesystem that can be accessed by the\r\nresizing libraries. If images are stored in Tahoe, to resize them,\r\nthey must be downloaded via HTTP GET (which involves decrypting and\r\nde-erasure coding them), resized, and then inserted back into the grid\r\nvia HTTP POST (which involves encrypting and erasure coding them). The\r\nlatency involved in that pretty much requires the approach of scaling\r\nthe images to preset sizes beforehand (and losing that sorl style\r\ndesign flexibility). \r\n\r\nSystem Description\r\n------------------\r\n\r\nReticulum attempts to address these issues and achieve a good balance. \r\n\r\nReticulum runs as one or more nodes (probably on seperate servers) with\r\nan HTTP/REST interface. The nodes are aware of each other and will\r\ndistribute the storage of images between themselves in an intelligent\r\nfashion. Any image stored in the grid can be retrieved through any\r\nnode in the grid. Images are retrieved via HTTP by their id, which is\r\na short string hash of the contents of the full-size image, and a size\r\nspecification. It looks something like this:\r\n\r\n* a \"client\" web application accepts an image upload from a user, and\r\n  POSTs that image file to one of the reticulum nodes that it knows\r\n  about.\r\n* the reticulum node stores the image to one or more nodes in the grid\r\n  and gives the client the image id for later retrieval\r\n* the client saves that image id (probably in a database\r\n  somewhere). It's just a tiny text string, so that's easy.\r\n* the display/view/template layer of the client application, on a page\r\n  where that image is to be displayed, just constructs a URL pointing\r\n  to an reticulum node with the image id and a size specification and\r\n  puts that URL into the src of an image tag.\r\n* the user's browser loads the page, parses out the image tag and\r\n  makes a GET request to the reticulum node\r\n* the reticulum node retrieves the image either from it's own local\r\n  storage or from another node in the grid that has it, scales it to\r\n  the requested size (if necessary), and serves it to the browser.\r\n\r\nThe advantages of this approach:\r\n\r\n* image storing/serving/resizing is separated from the main\r\n  application server, allowing you to scale those resources separately\r\n  and/or differently\r\n* design flexibility for thumbnail size is retained (no batch resize\r\n  scripts to write)\r\n* the cluster can be nicely load-balanced (nginx's load balancing and\r\n  caching is a winner here)\r\n* the cluster handles replication and high availability automatically\r\n  (it uses a distributed hash table to spread image copies between\r\n  nodes in a stable, efficient manner). If you have enough nodes and\r\n  enough replication, you might not need extra backup solutions.\r\n* The cluster supports easy dynamic adding and dropping of nodes. (The\r\n  approach is inspired by Riak and Amazon's Dynamo model).\r\n* The cluster scales out linearly.\r\n* A cluster of reticulum nodes can handle more images than would fit on\r\n  a single disk.\r\n* Since the interface is all HTTP, you can use it with any web\r\n  application/framework written in any language. If you change your\r\n  application or rewrite, you don't have to also change/rewrite your\r\n  image scaling/serving.\r\n\r\nImplementation Details\r\n----------------------\r\n\r\nWritten in Go.\r\n\r\nImages ids are just SHA1 hashes of the contents of the images. Images\r\nare stored on disk in a directory structure based on the hash (ie, no\r\ndatabase hits required to check if the node has an image). \r\n\r\nInter-node communication is HTTP. Nodes \"gossip\" with the other nodes\r\nthey are aware of to keep the entire cluster updated about all nodes'\r\nstatus. \r\n\r\nConfiguration\r\n-------------\r\n\r\nTODO. \r\n\r\nKnown Issues\r\n------------\r\n\r\nSee: https://github.com/thraxil/reticulum/issues\r\n\r\nFuture Roadmap\r\n--------------\r\n\r\nSee TODO.txt\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}